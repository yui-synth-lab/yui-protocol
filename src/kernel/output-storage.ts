import { writeFile, readFile, readdir, unlink } from 'fs/promises';
import { existsSync, mkdirSync } from 'fs';
import { join } from 'path';
import { getRAGManager } from './rag/rag-manager.js';
import { Message } from '../types/index.js';

export interface SavedOutput {
  id: string;
  title: string;
  content: string;
  userPrompt: string;
  language: 'en' | 'ja';
  createdAt: Date;
  sessionId: string;
  agentId: string;
  sequenceNumber: number;
}

export class OutputStorage {
  private outputDir: string;

  constructor(outputDir: string = 'outputs') {
    this.outputDir = outputDir;
    this.ensureOutputDirectory();
  }

  private ensureOutputDirectory(): void {
    if (!existsSync(this.outputDir)) {
      mkdirSync(this.outputDir, { recursive: true });
    }
  }

  public async saveOutput(
    title: string,
    content: string,
    userPrompt: string,
    language: 'en' | 'ja',
    sessionId: string,
    agentId: string,
    sequenceNumber: number,
    sessionMessages?: Message[]
  ): Promise<SavedOutput> {
    const id = `${sessionId}_${sequenceNumber}`;
    const timestamp = new Date();

    const output: SavedOutput = {
      id,
      title,
      content,
      userPrompt,
      language,
      createdAt: timestamp,
      sessionId,
      agentId,
      sequenceNumber
    };

    const filename = `${id}.md`;
    const filepath = join(this.outputDir, filename);

    // Create markdown content
    const markdownContent = this.createMarkdownContent(output);

    await writeFile(filepath, markdownContent, 'utf-8');
    console.log(`[OutputStorage] Saved output to ${filepath}`);

    // RAGè‡ªå‹•ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åŒ–ï¼ˆoutputsï¼‰
    await this.autoIndexToRAG(filepath);

    // RAGè‡ªå‹•ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åŒ–ï¼ˆsessionsï¼‰
    if (sessionMessages && sessionMessages.length > 0) {
      await this.autoIndexSessionToRAG(sessionId, sessionMessages);
    }

    return output;
  }

  private createMarkdownContent(output: SavedOutput): string {
    const { title, content, userPrompt, language, createdAt, sessionId, agentId, sequenceNumber } = output;

    return `# ${title}

**Session ID:** ${sessionId}
**Sequence Number:** ${sequenceNumber}
**Agent ID:** ${agentId}
**Language:** ${language === 'ja' ? 'Japanese' : 'English'}
**Created:** ${createdAt.toISOString()}

## User Query
${userPrompt}

## AI Collaboration Output
${content}

---
*Generated by Yui Protocol AI Collaboration System*
`;
  }

  public async getAllOutputs(): Promise<SavedOutput[]> {
    try {
      const files = await readdir(this.outputDir, { withFileTypes: true });
      const outputFiles = files.filter(file => file.isFile() && file.name.endsWith('.md'));

      const outputs: SavedOutput[] = [];

      for (const file of outputFiles) {
        try {
          const filepath = join(this.outputDir, file.name);
          const content = await readFile(filepath, 'utf-8');

          // Extract metadata from markdown content
          const output = this.parseMarkdownContent(content, file.name.replace('.md', ''));
          if (output) {
            outputs.push(output);
          }
        } catch (error) {
          console.error(`[OutputStorage] Error reading file ${file.name}:`, error);
        }
      }

      // Sort by creation date (newest first)
      return outputs.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
    } catch (error) {
      console.error('[OutputStorage] Error reading outputs directory:', error);
      return [];
    }
  }

  private parseMarkdownContent(content: string, id: string): SavedOutput | null {
    try {
      const lines = content.split('\n');
      const title = lines[0].replace('# ', '');

      // Extract metadata
      const sessionIdMatch = content.match(/\*\*Session ID:\*\* (.+)/);
      const sequenceNumberMatch = content.match(/\*\*Sequence Number:\*\* (\d+)/);
      const agentIdMatch = content.match(/\*\*Agent ID:\*\* (.+)/);
      const languageMatch = content.match(/\*\*Language:\*\* (.+)/);
      const createdMatch = content.match(/\*\*Created:\*\* (.+)/);

      // Extract user query and content
      const userQueryMatch = content.match(/## User Query\n([\s\S]*?)\n## AI Collaboration Output/);
      const contentMatch = content.match(/## AI Collaboration Output\n([\s\S]*?)\n---/);

      if (!sessionIdMatch || !sequenceNumberMatch || !agentIdMatch || !languageMatch || !createdMatch || !userQueryMatch || !contentMatch) {
        return null;
      }

      return {
        id,
        title,
        content: contentMatch[1].trim(),
        userPrompt: userQueryMatch[1].trim(),
        language: languageMatch[1].trim() === 'Japanese' ? 'ja' : 'en',
        createdAt: new Date(createdMatch[1]),
        sessionId: sessionIdMatch[1].trim(),
        agentId: agentIdMatch[1].trim(),
        sequenceNumber: parseInt(sequenceNumberMatch[1], 10)
      };
    } catch (error) {
      console.error('[OutputStorage] Error parsing markdown content:', error);
      return null;
    }
  }

  public async getOutput(id: string): Promise<SavedOutput | string |null> {
    try {
      const filepath = join(this.outputDir, `${id}.md`);
      const content = await readFile(filepath, 'utf-8');
      return this.parseMarkdownContent(content, id);
    } catch (error) {
      try {
        const filepath = join(this.outputDir, id);
        const content = await readFile(filepath, 'utf-8');
        return content;
      }
      catch {
        console.error(`[OutputStorage] Error reading output ${id}:`, error);
      }
      console.error(`[OutputStorage] Error reading output ${id}:`, error);
      return null;
    }
  }

  public async deleteOutput(id: string): Promise<boolean> {
    try {
      const filepath = join(this.outputDir, `${id}.md`);
      await unlink(filepath);
      console.log(`[OutputStorage] Deleted output ${id}`);
      return true;
    } catch (error) {
      console.error(`[OutputStorage] Error deleting output ${id}:`, error);
      return false;
    }
  }

  /**
   * RAGè‡ªå‹•ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åŒ–ï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼‰
   * ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è‡ªå‹•çš„ã«RAGã‚·ã‚¹ãƒ†ãƒ ã«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åŒ–
   */
  private async autoIndexSessionToRAG(sessionId: string, messages: Message[]): Promise<void> {
    try {
      const ragManager = getRAGManager();

      // RAGãŒæœ‰åŠ¹ã§ãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
      if (!ragManager.isReady()) {
        return;
      }

      // è¨­å®šã§è‡ªå‹•ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒç„¡åŠ¹ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
      const stats = await ragManager.getStats();
      if (!stats.config.indexing.autoIndexSessions) {
        return;
      }

      // ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åŒ–
      console.log(`[OutputStorage] ğŸ” Auto-indexing session ${sessionId} to RAG`);
      const chunksIndexed = await ragManager.indexSessionMessages(sessionId, messages);

      if (chunksIndexed > 0) {
        console.log(`[OutputStorage] âœ“ Auto-indexed ${chunksIndexed} chunks from session ${sessionId}`);
      }
    } catch (error) {
      console.warn('[OutputStorage] âš ï¸  Failed to auto-index session to RAG:', error);
    }
  }

  /**
   * RAGè‡ªå‹•ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åŒ–
   * æ–°ã—ãä¿å­˜ã•ã‚ŒãŸMarkdownãƒ•ã‚¡ã‚¤ãƒ«ã‚’è‡ªå‹•çš„ã«RAGã‚·ã‚¹ãƒ†ãƒ ã«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åŒ–
   */
  private async autoIndexToRAG(filepath: string): Promise<void> {
    try {
      const ragManager = getRAGManager();

      // RAGãŒæœ‰åŠ¹ã§ãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
      if (!ragManager.isReady()) {
        return; // Silently skip if RAG is not ready
      }

      // è¨­å®šã§è‡ªå‹•ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒç„¡åŠ¹ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
      const stats = await ragManager.getStats();
      if (!stats.config.indexing.autoIndexOutputs) {
        console.log('[OutputStorage] Auto-indexing outputs is disabled in config');
        return;
      }

      const retriever = ragManager.getRetriever();
      if (!retriever) {
        return;
      }

      // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åŒ–
      console.log(`[OutputStorage] ğŸ” Auto-indexing to RAG: ${filepath}`);
      const chunksIndexed = await retriever.indexLocalDocuments([filepath]);

      console.log(`[OutputStorage] âœ“ Auto-indexed ${chunksIndexed} chunks to RAG`);
    } catch (error) {
      // RAGã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åŒ–ãŒå¤±æ•—ã—ã¦ã‚‚ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ã¯æˆåŠŸã•ã›ã‚‹
      console.warn('[OutputStorage] âš ï¸  Failed to auto-index to RAG:', error);
      console.warn('[OutputStorage] Output file saved, but not indexed. You can manually index it later.');
    }
  }
} 