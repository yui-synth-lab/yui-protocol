import { writeFile, readFile, readdir, unlink } from 'fs/promises';
import { existsSync, mkdirSync } from 'fs';
import { join } from 'path';

export interface SavedOutput {
  id: string;
  title: string;
  content: string;
  userPrompt: string;
  language: 'en' | 'ja';
  createdAt: Date;
  sessionId: string;
  agentId: string;
  sequenceNumber: number;
}

export class OutputStorage {
  private outputDir: string;

  constructor(outputDir: string = 'outputs') {
    this.outputDir = outputDir;
    this.ensureOutputDirectory();
  }

  private ensureOutputDirectory(): void {
    if (!existsSync(this.outputDir)) {
      mkdirSync(this.outputDir, { recursive: true });
    }
  }

  public async saveOutput(
    title: string,
    content: string,
    userPrompt: string,
    language: 'en' | 'ja',
    sessionId: string,
    agentId: string,
    sequenceNumber: number
  ): Promise<SavedOutput> {
    const id = `${sessionId}_${sequenceNumber}`;
    const timestamp = new Date();

    const output: SavedOutput = {
      id,
      title,
      content,
      userPrompt,
      language,
      createdAt: timestamp,
      sessionId,
      agentId,
      sequenceNumber
    };

    const filename = `${id}.md`;
    const filepath = join(this.outputDir, filename);

    // Create markdown content
    const markdownContent = this.createMarkdownContent(output);

    await writeFile(filepath, markdownContent, 'utf-8');
    console.log(`[OutputStorage] Saved output to ${filepath}`);

    return output;
  }

  private createMarkdownContent(output: SavedOutput): string {
    const { title, content, userPrompt, language, createdAt, sessionId, agentId, sequenceNumber } = output;

    return `# ${title}

**Session ID:** ${sessionId}  
**Sequence Number:** ${sequenceNumber}  
**Agent ID:** ${agentId}  
**Language:** ${language === 'ja' ? 'Japanese' : 'English'}  
**Created:** ${createdAt.toISOString()}

## User Query
${userPrompt}

## AI Collaboration Output
${content}

---
*Generated by Yui Protocol AI Collaboration System*
`;
  }

  public async getAllOutputs(): Promise<SavedOutput[]> {
    try {
      const files = await readdir(this.outputDir, { withFileTypes: true });
      const outputFiles = files.filter(file => file.isFile() && file.name.endsWith('.md'));

      const outputs: SavedOutput[] = [];

      for (const file of outputFiles) {
        try {
          const filepath = join(this.outputDir, file.name);
          const content = await readFile(filepath, 'utf-8');

          // Extract metadata from markdown content
          const output = this.parseMarkdownContent(content, file.name.replace('.md', ''));
          if (output) {
            outputs.push(output);
          }
        } catch (error) {
          console.error(`[OutputStorage] Error reading file ${file.name}:`, error);
        }
      }

      // Sort by creation date (newest first)
      return outputs.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
    } catch (error) {
      console.error('[OutputStorage] Error reading outputs directory:', error);
      return [];
    }
  }

  private parseMarkdownContent(content: string, id: string): SavedOutput | null {
    try {
      const lines = content.split('\n');
      const title = lines[0].replace('# ', '');

      // Extract metadata
      const sessionIdMatch = content.match(/\*\*Session ID:\*\* (.+)/);
      const sequenceNumberMatch = content.match(/\*\*Sequence Number:\*\* (\d+)/);
      const agentIdMatch = content.match(/\*\*Agent ID:\*\* (.+)/);
      const languageMatch = content.match(/\*\*Language:\*\* (.+)/);
      const createdMatch = content.match(/\*\*Created:\*\* (.+)/);

      // Extract user query and content
      const userQueryMatch = content.match(/## User Query\n([\s\S]*?)\n## AI Collaboration Output/);
      const contentMatch = content.match(/## AI Collaboration Output\n([\s\S]*?)\n---/);

      if (!sessionIdMatch || !sequenceNumberMatch || !agentIdMatch || !languageMatch || !createdMatch || !userQueryMatch || !contentMatch) {
        return null;
      }

      return {
        id,
        title,
        content: contentMatch[1].trim(),
        userPrompt: userQueryMatch[1].trim(),
        language: languageMatch[1].trim() === 'Japanese' ? 'ja' : 'en',
        createdAt: new Date(createdMatch[1]),
        sessionId: sessionIdMatch[1].trim(),
        agentId: agentIdMatch[1].trim(),
        sequenceNumber: parseInt(sequenceNumberMatch[1], 10)
      };
    } catch (error) {
      console.error('[OutputStorage] Error parsing markdown content:', error);
      return null;
    }
  }

  public async getOutput(id: string): Promise<SavedOutput | string |null> {
    try {
      const filepath = join(this.outputDir, `${id}.md`);
      const content = await readFile(filepath, 'utf-8');
      return this.parseMarkdownContent(content, id);
    } catch (error) {
      try {
        const filepath = join(this.outputDir, id);
        const content = await readFile(filepath, 'utf-8');
        return content;
      }
      catch {
        console.error(`[OutputStorage] Error reading output ${id}:`, error);
      }
      console.error(`[OutputStorage] Error reading output ${id}:`, error);
      return null;
    }
  }

  public async deleteOutput(id: string): Promise<boolean> {
    try {
      const filepath = join(this.outputDir, `${id}.md`);
      await unlink(filepath);
      console.log(`[OutputStorage] Deleted output ${id}`);
      return true;
    } catch (error) {
      console.error(`[OutputStorage] Error deleting output ${id}:`, error);
      return false;
    }
  }
} 