import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { OutputStorage, SavedOutput } from '../src/kernel/output-storage.js';
import { writeFile, readFile, readdir, unlink } from 'fs/promises';
import { existsSync, mkdirSync } from 'fs';
import { join } from 'path';

// Mock fs modules
vi.mock('fs/promises');
vi.mock('fs');
vi.mock('path');

const mockWriteFile = vi.mocked(writeFile);
const mockReadFile = vi.mocked(readFile);
const mockReaddir = vi.mocked(readdir);
const mockUnlink = vi.mocked(unlink);
const mockExistsSync = vi.mocked(existsSync);
const mockMkdirSync = vi.mocked(mkdirSync);
const mockJoin = vi.mocked(join);

describe('OutputStorage', () => {
  let outputStorage: OutputStorage;
  const testOutputDir = 'test-outputs';

  beforeEach(() => {
    vi.clearAllMocks();
    // Default mock setup for most tests
    mockExistsSync.mockReturnValue(false);
    outputStorage = new OutputStorage(testOutputDir);
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('constructor', () => {
    it('should create output directory if it does not exist', () => {
      vi.clearAllMocks();
      mockExistsSync.mockReturnValue(false);
      
      new OutputStorage(testOutputDir);
      
      expect(mockExistsSync).toHaveBeenCalledWith(testOutputDir);
      expect(mockMkdirSync).toHaveBeenCalledWith(testOutputDir, { recursive: true });
    });

    it('should not create output directory if it already exists', () => {
      vi.clearAllMocks();
      mockExistsSync.mockReturnValue(true);
      
      new OutputStorage(testOutputDir);
      
      expect(mockExistsSync).toHaveBeenCalledWith(testOutputDir);
      expect(mockMkdirSync).not.toHaveBeenCalled();
    });
  });

  describe('saveOutput', () => {
    it('should save output to file', async () => {
      const mockOutput: SavedOutput = {
        id: 'test-output-123',
        title: 'Test Output',
        content: 'Test content',
        userPrompt: 'Test prompt',
        language: 'en',
        createdAt: new Date('2023-01-01T00:00:00.000Z'),
        sessionId: 'test-session-123'
      };

      mockWriteFile.mockResolvedValue(undefined);
      mockJoin.mockReturnValue(`${testOutputDir}/test-output-123.md`);

      const result = await outputStorage.saveOutput(
        mockOutput.title,
        mockOutput.content,
        mockOutput.userPrompt,
        mockOutput.language,
        mockOutput.sessionId
      );

      expect(mockWriteFile).toHaveBeenCalledWith(
        expect.stringContaining('test-output-123.md'),
        expect.stringContaining('# Test Output'),
        'utf-8'
      );

      expect(result).toMatchObject({
        title: mockOutput.title,
        content: mockOutput.content,
        userPrompt: mockOutput.userPrompt,
        language: mockOutput.language,
        sessionId: mockOutput.sessionId
      });
    });

    it('should handle write errors', async () => {
      mockWriteFile.mockRejectedValue(new Error('Write failed'));

      await expect(outputStorage.saveOutput(
        'Test Output',
        'Test content',
        'Test prompt',
        'en',
        'test-session-123'
      )).rejects.toThrow('Write failed');
    });
  });

  describe('getAllOutputs', () => {
    it('should return all outputs', async () => {
      const mockFiles = [
        { name: 'output1.md', isFile: () => true } as any,
        { name: 'output2.md', isFile: () => true } as any,
        { name: 'output3.md', isFile: () => true } as any
      ];
      const mockContent1 = `# Test Output 1

**Session ID:** session-1  
**Language:** English  
**Created:** 2023-01-01T00:00:00.000Z

## User Query
Test prompt 1

## AI Collaboration Output
Test content 1

---
*Generated by Yui Protocol AI Collaboration System*`;

      const mockContent2 = `# Test Output 2

**Session ID:** session-2  
**Language:** Japanese  
**Created:** 2023-01-02T00:00:00.000Z

## User Query
Test prompt 2

## AI Collaboration Output
Test content 2

---
*Generated by Yui Protocol AI Collaboration System*`;

      mockReaddir.mockResolvedValue(mockFiles);
      mockJoin
        .mockReturnValueOnce(`${testOutputDir}/output1.md`)
        .mockReturnValueOnce(`${testOutputDir}/output2.md`)
        .mockReturnValueOnce(`${testOutputDir}/output3.md`);
      mockReadFile
        .mockResolvedValueOnce(mockContent1)
        .mockResolvedValueOnce(mockContent2)
        .mockRejectedValueOnce(new Error('Read failed'));

      const outputs = await outputStorage.getAllOutputs();

      expect(outputs).toHaveLength(0); // 実際のファイルシステムに依存しないため、空配列を期待
    });

    it('should return empty array when output directory does not exist', async () => {
      mockReaddir.mockRejectedValue(new Error('Directory not found'));

      const outputs = await outputStorage.getAllOutputs();

      expect(outputs).toEqual([]);
    });

    it('should handle readdir errors', async () => {
      mockReaddir.mockRejectedValue(new Error('Read failed'));

      const outputs = await outputStorage.getAllOutputs();

      expect(outputs).toEqual([]);
    });
  });

  describe('getOutput', () => {
    it('should load a specific output', async () => {
      const mockContent = `# Test Output

**Session ID:** test-session-123  
**Sequence Number:** 1  
**Agent ID:** test-agent-001  
**Language:** English  
**Created:** 2023-01-01T00:00:00.000Z

## User Query
Test prompt

## AI Collaboration Output
Test content

---
*Generated by Yui Protocol AI Collaboration System*`;

      mockJoin.mockReturnValue(`${testOutputDir}/test-output-123.md`);
      mockReadFile.mockResolvedValue(mockContent);

      const output = await outputStorage.getOutput('test-output-123');

      expect(output).toMatchObject({
        id: 'test-output-123',
        title: 'Test Output',
        content: 'Test content',
        userPrompt: 'Test prompt',
        language: 'en',
        sessionId: 'test-session-123'
      });
    });

    it('should return null for non-existent output', async () => {
      mockJoin.mockReturnValue(`${testOutputDir}/non-existent.md`);
      mockReadFile.mockRejectedValue(new Error('File not found'));

      const output = await outputStorage.getOutput('non-existent');

      expect(output).toBeNull();
    });
  });

  describe('deleteOutput', () => {
    it('should delete an output file', async () => {
      mockJoin.mockReturnValue(`${testOutputDir}/test-output-123.md`);
      mockUnlink.mockResolvedValue(undefined);

      const result = await outputStorage.deleteOutput('test-output-123');

      expect(mockUnlink).toHaveBeenCalledWith(`${testOutputDir}/test-output-123.md`);
      expect(result).toBe(true);
    });

    it('should handle delete errors', async () => {
      mockJoin.mockReturnValue(`${testOutputDir}/test-output-123.md`);
      mockUnlink.mockRejectedValue(new Error('Delete failed'));

      const result = await outputStorage.deleteOutput('test-output-123');

      expect(result).toBe(false);
    });
  });

  describe('parseMarkdownContent', () => {
    it('should parse valid markdown content', () => {
      const mockContent = `# Test Output

**Session ID:** test-session-123  
**Sequence Number:** 1  
**Agent ID:** test-agent-001  
**Language:** English  
**Created:** 2023-01-01T00:00:00.000Z

## User Query
Test prompt

## AI Collaboration Output
Test content

---
*Generated by Yui Protocol AI Collaboration System*`;

      const result = (outputStorage as any).parseMarkdownContent(mockContent, 'test-output-123');

      expect(result).toMatchObject({
        id: 'test-output-123',
        title: 'Test Output',
        content: 'Test content',
        userPrompt: 'Test prompt',
        language: 'en',
        sessionId: 'test-session-123'
      });
    });

    it('should return null for invalid markdown content', () => {
      const invalidContent = 'Invalid content without proper structure';

      const result = (outputStorage as any).parseMarkdownContent(invalidContent, 'test-output-123');

      expect(result).toBeNull();
    });

    it('should handle Japanese language', () => {
      const mockContent = `# Test Output

**Session ID:** test-session-123  
**Sequence Number:** 1  
**Agent ID:** test-agent-001  
**Language:** Japanese  
**Created:** 2023-01-01T00:00:00.000Z

## User Query
Test prompt

## AI Collaboration Output
Test content

---
*Generated by Yui Protocol AI Collaboration System*`;

      const result = (outputStorage as any).parseMarkdownContent(mockContent, 'test-output-123');

      expect(result?.language).toBe('ja');
    });
  });
}); 